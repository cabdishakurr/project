import { GetOptions, DocumentChangeType } from './common';
export { GetOptions, DocumentChangeType };
import { WhereFilterOp, ICollectionReference, IDocumentReference, IFieldPath, IFieldValue, IGeoPoint, IQuery, ITimestamp, IWriteBatch, SetOptions, DocumentData, IDocumentSnapshot, IQuerySnapshot, SnapshotListenOptions, ISnapshotMetadata, IDocumentChange, IQueryDocumentSnapshot, ITransaction, ISettings, IFirestore, IBytes, DocumentFieldType } from '.';
import { FirebaseApp } from '@nativescript/firebase-core';
import '@nativescript/core';
export declare class Transaction implements ITransaction {
    _native: FIRTransaction;
    static fromNative(transaction: FIRTransaction): Transaction;
    delete<T extends DocumentData = DocumentData>(documentRef: DocumentReference): Transaction;
    get<T extends DocumentData = DocumentData>(documentRef: DocumentReference<T>): Promise<DocumentSnapshot<T>>;
    update<T extends DocumentData = DocumentData>(documentRef: DocumentReference<T>, data: Partial<{
        [K in keyof T]: T[K] | FieldValue;
    }>): Transaction;
    update<T extends DocumentData = DocumentData, K extends keyof T = string>(documentRef: DocumentReference<T>, field: K | FieldPath, value: T[K], moreFieldsAndValues: any[]): Transaction;
    set<T extends DocumentData = DocumentData>(documentRef: DocumentReference<T>, data: T, options?: SetOptions): Transaction;
    get ios(): FIRTransaction;
    get native(): FIRTransaction;
}
export declare class SnapshotMetadata implements ISnapshotMetadata {
    _native: FIRSnapshotMetadata;
    static fromNative(metadata: FIRSnapshotMetadata): SnapshotMetadata;
    get fromCache(): boolean;
    get hasPendingWrites(): boolean;
    toJSON(): {
        fromCache: boolean;
        hasPendingWrites: boolean;
    };
    get native(): FIRSnapshotMetadata;
    get ios(): FIRSnapshotMetadata;
}
export declare class DocumentSnapshot<T extends DocumentData = DocumentData> implements IDocumentSnapshot<T> {
    _native: FIRDocumentSnapshot;
    static fromNative(snapshot: FIRDocumentSnapshot): DocumentSnapshot<DocumentData>;
    get exists(): boolean;
    get id(): string;
    get metadata(): SnapshotMetadata;
    get ref(): DocumentReference;
    data(): any;
    get<fieldType extends DocumentFieldType>(fieldPath: string | number | FieldPath): fieldType;
    toJSON(): {
        exists: boolean;
        id: string;
        metadata: SnapshotMetadata;
        ref: DocumentReference<DocumentData>;
        data: () => any;
    };
    get native(): FIRDocumentSnapshot;
    get ios(): FIRDocumentSnapshot;
}
export declare class DocumentChange implements IDocumentChange {
    _native: FIRDocumentChange;
    static fromNative(change: FIRDocumentChange): DocumentChange;
    get doc(): QueryDocumentSnapshot<DocumentData>;
    get newIndex(): number;
    get oldIndex(): number;
    get type(): DocumentChangeType;
    toJSON(): {
        doc: QueryDocumentSnapshot<DocumentData>;
        newIndex: number;
        oldIndex: number;
        type: DocumentChangeType;
    };
    get native(): FIRDocumentChange;
    get ios(): FIRDocumentChange;
}
export declare class Query<T extends DocumentData = DocumentData> implements IQuery<T> {
    _native: FIRQuery;
    static fromNative(query: FIRQuery): Query;
    endAt(snapshot: DocumentSnapshot<T>): Query;
    endAt(fieldValues: FieldValue[]): Query;
    endBefore(snapshot: DocumentSnapshot<T>): Query;
    endBefore(fieldValues: FieldValue[]): Query;
    get(options?: GetOptions): Promise<QuerySnapshot>;
    limit(limit: number): Query<DocumentData>;
    limitToLast(limitToLast: number): Query<DocumentData>;
    onSnapshot(observer: {
        complete?: () => void;
        error?: (error: Error) => void;
        next?: (snapshot: QuerySnapshot) => void;
    }): () => void;
    onSnapshot(options: SnapshotListenOptions, observer: {
        complete?: () => void;
        error?: (error: Error) => void;
        next?: (snapshot: QuerySnapshot) => void;
    }): () => void;
    onSnapshot(onNext: (snapshot: QuerySnapshot) => void, onError?: (error: Error) => void, onCompletion?: () => void): () => void;
    onSnapshot(options: SnapshotListenOptions, onNext: (snapshot: QuerySnapshot) => void, onError?: (error: Error) => void, onCompletion?: () => void): () => void;
    orderBy(fieldPath: keyof DocumentData | FieldPath, directionStr?: 'asc' | 'desc'): Query;
    startAfter(snapshot: DocumentSnapshot<T>): Query;
    startAfter(fieldValues: FieldValue[]): Query;
    startAt(snapshot: DocumentSnapshot<T>): Query;
    startAt(fieldValues: FieldValue[]): Query;
    where(fieldPath: FieldPath | keyof DocumentData, opStr: WhereFilterOp, value: any): Query;
    isEqual(other: Query): boolean;
    get native(): FIRQuery;
    get ios(): FIRQuery;
}
export declare class QueryDocumentSnapshot<T extends DocumentData = DocumentData> extends DocumentSnapshot<T> implements IQueryDocumentSnapshot<T> {
    _native: FIRQueryDocumentSnapshot;
    static fromNative(snapshot: FIRQueryDocumentSnapshot): QueryDocumentSnapshot<DocumentData>;
    data(): any;
    get<fieldType extends DocumentFieldType>(fieldPath: string | number | FieldPath): fieldType;
    get native(): FIRQueryDocumentSnapshot;
    get ios(): FIRQueryDocumentSnapshot;
}
export declare class QuerySnapshot implements IQuerySnapshot {
    _native: FIRQuerySnapshot;
    static fromNative(snapshot: FIRQuerySnapshot): QuerySnapshot;
    get docs(): any[];
    get empty(): boolean;
    get metadata(): SnapshotMetadata;
    get query(): Query<DocumentData>;
    get size(): number;
    docChanges(options?: SnapshotListenOptions): DocumentChange[];
    forEach(callback: (result: QueryDocumentSnapshot, index: number) => void, thisArg?: any): void;
    toJSON(): {
        docs: any[];
        empty: boolean;
        metadata: SnapshotMetadata;
        size: number;
    };
    get native(): FIRQuerySnapshot;
    get ios(): FIRQuerySnapshot;
}
export declare class CollectionReference<T extends DocumentData = DocumentData> extends Query<T> implements ICollectionReference<T> {
    _native: FIRCollectionReference;
    static fromNative(collection: FIRCollectionReference): CollectionReference<DocumentData>;
    get id(): string;
    get parent(): DocumentReference;
    get path(): string;
    add(data: T): Promise<DocumentReference<T>>;
    doc(documentPath?: string): DocumentReference<DocumentData>;
    toJSON(): {
        id: string;
        path: string;
        parent: DocumentReference<DocumentData>;
    };
    get native(): FIRCollectionReference;
    get ios(): FIRCollectionReference;
}
export declare class DocumentReference<T extends DocumentData = DocumentData> implements IDocumentReference<T> {
    _native: FIRDocumentReference;
    static fromNative(document: FIRDocumentReference): DocumentReference<DocumentData>;
    get firestore(): Firestore;
    get id(): string;
    get parent(): CollectionReference<DocumentData>;
    get path(): string;
    collection(collectionPath: string): CollectionReference<DocumentData>;
    delete(): Promise<void>;
    get(options?: GetOptions): Promise<DocumentSnapshot<T>>;
    onSnapshot(observer: {
        complete?: () => void;
        error?: (error: Error) => void;
        next?: (snapshot: DocumentSnapshot<T>) => void;
    }): () => void;
    onSnapshot(options: SnapshotListenOptions, observer: {
        complete?: () => void;
        error?: (error: Error) => void;
        next?: (snapshot: DocumentSnapshot<T>) => void;
    }): () => void;
    onSnapshot(onNext: (snapshot: DocumentSnapshot<T>) => void, onError?: (error: Error) => void, onCompletion?: () => void): () => void;
    onSnapshot(options: SnapshotListenOptions, onNext: (snapshot: DocumentSnapshot<T>) => void, onError?: (error: Error) => void, onCompletion?: () => void): () => void;
    set(data: T, options?: SetOptions): Promise<void>;
    update(data: Partial<{
        [K in keyof T]: FieldValue | T[K];
    }>): Promise<void>;
    update(field: FieldPath | keyof T, value: any, moreFieldsAndValues: any[]): Promise<void>;
    toJSON(): {
        id: string;
        path: string;
        parent: CollectionReference<DocumentData>;
    };
    get native(): FIRDocumentReference;
    get ios(): FIRDocumentReference;
}
export declare class FieldPath implements IFieldPath {
    _native: FIRFieldPath;
    constructor(fieldNames: string[], native?: boolean);
    private _addToMap;
    static fromNative(field: FIRFieldPath): FieldPath;
    get native(): FIRFieldPath;
    get ios(): FIRFieldPath;
    static documentId(): FieldPath;
    toString(): string;
}
export declare class FieldValue implements IFieldValue {
    _native: FIRFieldValue;
    static fromNative(field: FIRFieldValue): FieldValue;
    static arrayRemove(elements: any[]): FieldValue;
    static arrayUnion(elements: any[]): FieldValue;
    static delete(): FieldValue;
    static increment(n: number): FieldValue;
    static serverTimestamp(): FieldValue;
    get native(): FIRFieldValue;
    get ios(): FIRFieldValue;
}
export declare class GeoPoint implements IGeoPoint {
    _native: FIRGeoPoint;
    constructor(latitude: number, longitude: number, native?: boolean);
    static fromNative(point: FIRGeoPoint): GeoPoint;
    get latitude(): number;
    get longitude(): number;
    get native(): FIRGeoPoint;
    get ios(): FIRGeoPoint;
    toJSON(): {
        latitude: number;
        longitude: number;
    };
}
export declare class Timestamp implements ITimestamp {
    _native: FIRTimestamp;
    constructor(seconds: number, nanoseconds: number, native?: boolean);
    static fromNative(timestamp: FIRTimestamp): Timestamp;
    static fromDate(date: Date): Timestamp;
    static fromMillis(milliseconds: number): Timestamp;
    static now(): Timestamp;
    get nanoseconds(): number;
    get seconds(): number;
    isEqual(ts: Timestamp): boolean;
    toDate(): Date;
    toMillis(): number;
    valueOf(): string;
    get native(): FIRTimestamp;
    get ios(): FIRTimestamp;
    toJSON(): {
        nanoseconds: number;
        seconds: number;
    };
}
export declare class WriteBatch implements IWriteBatch {
    _native: FIRWriteBatch;
    static fromNative(batch: FIRWriteBatch): WriteBatch;
    commit(): Promise<void>;
    delete(documentRef: DocumentReference): WriteBatch;
    set(documentRef: DocumentReference, data: DocumentData, options?: SetOptions): WriteBatch;
    update<T extends DocumentData = DocumentData>(documentRef: DocumentReference<T>, data: Partial<{
        [K in keyof T]: T[K] | FieldValue;
    }>): WriteBatch;
    update<T extends DocumentData = DocumentData, K extends keyof T = string>(documentRef: DocumentReference<T>, field: K | FieldPath, value: FieldValue | T[K], moreFieldAndValues: any[]): WriteBatch;
    get native(): FIRWriteBatch;
    get ios(): FIRWriteBatch;
}
export declare class Settings implements ISettings {
    _native: FIRFirestoreSettings;
    _firestore: FIRFirestore;
    static fromNative(ffs: FIRFirestoreSettings, firestore?: any): Settings;
    _updateStoreSettings(): void;
    get cacheSizeBytes(): number;
    set cacheSizeBytes(value: number);
    get host(): string;
    set host(value: string);
    ignoreUndefinedProperties: boolean;
    get persistence(): boolean;
    set persistence(value: boolean);
    get ssl(): boolean;
    set ssl(value: boolean);
    toJSON(): {
        cacheSizeBytes: number;
        host: string;
        ignoreUndefinedProperties: boolean;
        persistence: boolean;
        ssl: boolean;
    };
    get ios(): FIRFirestoreSettings;
    get native(): FIRFirestoreSettings;
}
export declare class Bytes implements IBytes {
    _native: NSData;
    static fromNative(data: NSData): Bytes;
    static fromBase64String(base64: any): Bytes;
    static fromUint8Array(array: any): Bytes;
    toBase64(): string;
    toUint8Array(): Uint8Array;
    get native(): NSData;
    get ios(): NSData;
}
export declare class Firestore implements IFirestore {
    _native: FIRFirestore;
    _app: FirebaseApp;
    constructor(app?: FirebaseApp);
    static fromNative(store: FIRFirestore): Firestore;
    useEmulator(host: string, port: number): void;
    batch(): WriteBatch;
    collection(collectionPath: string): CollectionReference;
    clearPersistence(): Promise<void>;
    collectionGroup(collectionId: string): any;
    disableNetwork(): Promise<void>;
    doc(documentPath: string): DocumentReference;
    enableNetwork(): Promise<void>;
    runTransaction(updateFunction: (transaction: Transaction) => Promise<any>): Promise<any>;
    get settings(): Settings;
    set settings(value: Settings);
    terminate(): Promise<void>;
    waitForPendingWrites(): Promise<void>;
    get native(): FIRFirestore;
    get ios(): FIRFirestore;
    get app(): FirebaseApp;
}
